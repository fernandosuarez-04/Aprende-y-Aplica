import { NextRequest, NextResponse } from 'next/server';
import { SessionService } from '../../../../../../features/auth/services/session.service';
import { StudyPlannerService } from '../../../../../../features/study-planner/services/studyPlannerService';
import { CalendarSyncService } from '../../../../../../features/study-planner/services/calendarSyncService';
import { generateSessionsFromPreferences } from '../../../../../../features/study-planner/utils/sessionGenerator';

/**
 * POST /api/study-planner/sessions/bulk/regenerate
 * Regenera todas las sesiones basadas en las preferencias actuales
 */
export async function POST(request: NextRequest) {
  try {
    const user = await SessionService.getCurrentUser();

    if (!user) {
      return NextResponse.json(
        { success: false, error: 'No autenticado' },
        { status: 401 }
      );
    }

    // Obtener preferencias actuales
    const preferences = await StudyPlannerService.getStudyPreferences(user.id);
    
    if (!preferences) {
      return NextResponse.json(
        { success: false, error: 'No hay preferencias configuradas' },
        { status: 400 }
      );
    }

    console.log(`[BULK REGENERATE] Starting regeneration for user ${user.id}`);

    // Primero eliminar sesiones existentes generadas automáticamente
    const existingSessions = await StudyPlannerService.getStudySessions(user.id, {
      startDate: new Date().toISOString(),
    });

    const autoGeneratedSessions = existingSessions.filter(
      session => session.status === 'planned' && 
      session.description?.includes('programada automáticamente')
    );

    const integrations = await StudyPlannerService.getCalendarIntegrations(user.id);
    const activeIntegrations = integrations.filter(integration => integration.access_token);
    
    let deletedCount = 0;
    let deletedFromCalendar = 0;
    for (const session of autoGeneratedSessions) {
      // Eliminar de todos los calendarios externos activos
      if (session.external_event_id) {
        for (const integration of activeIntegrations) {
          try {
            await CalendarSyncService.deleteEvent(session, integration);
            deletedFromCalendar++;
          } catch (deleteError) {
            // Ignorar errores si el evento no existe en ese calendario
            console.log(`[BULK REGENERATE] Could not delete session from ${integration.provider} (may not exist there)`);
          }
        }
      }
      await StudyPlannerService.deleteStudySession(session.id, user.id);
      deletedCount++;
    }

    console.log(`[BULK REGENERATE] Deleted ${deletedCount} existing sessions (${deletedFromCalendar} from external calendars)`);

    // Generar nuevas sesiones
    const sessions = generateSessionsFromPreferences(preferences, new Date(), 4);
    console.log(`[BULK REGENERATE] Generated ${sessions.length} new sessions from preferences`);

    let createdCount = 0;
    let syncedCount = 0;
    for (const session of sessions) {
      try {
        const createdSession = await StudyPlannerService.createStudySession(session);
        createdCount++;

        // Sincronizar con todos los calendarios externos activos
        if (activeIntegrations.length > 0) {
          // Usar la primera integración para guardar el external_event_id principal
          const primaryIntegration = activeIntegrations[0];
          let primaryEventId: string | null = null;
          
          // Sincronizar con todas las integraciones
          for (const integration of activeIntegrations) {
            try {
              const eventId = await CalendarSyncService.createEvent(createdSession, integration);
              if (eventId) {
                // Guardar el ID de la primera integración como principal
                if (integration.provider === primaryIntegration.provider) {
                  primaryEventId = eventId;
                }
                syncedCount++;
                console.log(`[BULK REGENERATE] Synced session ${createdSession.id} to ${integration.provider} calendar`);
              }
            } catch (syncError) {
              console.error(`[BULK REGENERATE] Error syncing session to ${integration.provider}:`, syncError);
              // Continuar con las demás integraciones aunque falle una
            }
          }
          
          // Guardar el external_event_id de la primera integración
          if (primaryEventId) {
            await StudyPlannerService.updateStudySession(createdSession.id, user.id, {
              external_event_id: primaryEventId,
              calendar_provider: primaryIntegration.provider,
            });
          }
        }
      } catch (createError) {
        console.error('[BULK REGENERATE] Error creating session:', createError);
      }
    }

    console.log(`[BULK REGENERATE] Successfully created ${createdCount} sessions and synced ${syncedCount} to calendar for user ${user.id}`);

    return NextResponse.json({
      success: true,
      data: {
        deletedCount,
        deletedFromCalendar,
        createdCount,
        syncedCount,
      },
    });
  } catch (error) {
    console.error('[BULK REGENERATE] Error regenerating sessions:', error);
    return NextResponse.json(
      {
        success: false,
        error: {
          message: error instanceof Error ? error.message : 'Error desconocido',
          code: 'REGENERATE_SESSIONS_ERROR',
        },
      },
      { status: 500 }
    );
  }
}

