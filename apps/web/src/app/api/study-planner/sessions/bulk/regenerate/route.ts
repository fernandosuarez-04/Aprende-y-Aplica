import { NextRequest, NextResponse } from 'next/server';
import { SessionService } from '../../../../../../features/auth/services/session.service';
import { StudyPlannerService } from '../../../../../../features/study-planner/services/studyPlannerService';
import { CalendarSyncService } from '../../../../../../features/study-planner/services/calendarSyncService';
import { generateSessionsFromPreferences } from '../../../../../../features/study-planner/utils/sessionGenerator';

/**
 * POST /api/study-planner/sessions/bulk/regenerate
 * Regenera todas las sesiones basadas en las preferencias actuales
 */
export async function POST(request: NextRequest) {
  try {
    const user = await SessionService.getCurrentUser();

    if (!user) {
      return NextResponse.json(
        { success: false, error: 'No autenticado' },
        { status: 401 }
      );
    }

    // Obtener preferencias actuales
    const preferences = await StudyPlannerService.getStudyPreferences(user.id);
    
    if (!preferences) {
      return NextResponse.json(
        { success: false, error: 'No hay preferencias configuradas' },
        { status: 400 }
      );
    }

    console.log(`[BULK REGENERATE] Starting regeneration for user ${user.id}`);

    // Primero eliminar sesiones existentes generadas automáticamente
    const existingSessions = await StudyPlannerService.getStudySessions(user.id, {
      startDate: new Date().toISOString(),
    });

    const autoGeneratedSessions = existingSessions.filter(
      session => session.status === 'planned' && 
      session.description?.includes('programada automáticamente')
    );

    const integrations = await StudyPlannerService.getCalendarIntegrations(user.id);
    const activeIntegration = integrations.find(integration => integration.access_token);
    
    let deletedCount = 0;
    let deletedFromCalendar = 0;
    for (const session of autoGeneratedSessions) {
      if (session.external_event_id && activeIntegration) {
        try {
          await CalendarSyncService.deleteEvent(session, activeIntegration);
          deletedFromCalendar++;
        } catch (deleteError) {
          console.error('[BULK REGENERATE] Error deleting session from calendar:', deleteError);
        }
      }
      await StudyPlannerService.deleteStudySession(session.id, user.id);
      deletedCount++;
    }

    console.log(`[BULK REGENERATE] Deleted ${deletedCount} existing sessions (${deletedFromCalendar} from external calendar)`);

    // Generar nuevas sesiones
    const sessions = generateSessionsFromPreferences(preferences, new Date(), 4);
    console.log(`[BULK REGENERATE] Generated ${sessions.length} new sessions from preferences`);

    let createdCount = 0;
    let syncedCount = 0;
    for (const session of sessions) {
      try {
        const createdSession = await StudyPlannerService.createStudySession(session);
        createdCount++;

        // Sincronizar con calendario externo si hay integración activa
        if (activeIntegration) {
          try {
            const eventId = await CalendarSyncService.createEvent(createdSession, activeIntegration);
            if (eventId) {
              await StudyPlannerService.updateStudySession(createdSession.id, user.id, {
                external_event_id: eventId,
                calendar_provider: activeIntegration.provider,
              });
              syncedCount++;
            }
          } catch (syncError) {
            console.error('[BULK REGENERATE] Error syncing generated session to calendar:', syncError);
          }
        }
      } catch (createError) {
        console.error('[BULK REGENERATE] Error creating session:', createError);
      }
    }

    console.log(`[BULK REGENERATE] Successfully created ${createdCount} sessions and synced ${syncedCount} to calendar for user ${user.id}`);

    return NextResponse.json({
      success: true,
      data: {
        deletedCount,
        deletedFromCalendar,
        createdCount,
        syncedCount,
      },
    });
  } catch (error) {
    console.error('[BULK REGENERATE] Error regenerating sessions:', error);
    return NextResponse.json(
      {
        success: false,
        error: {
          message: error instanceof Error ? error.message : 'Error desconocido',
          code: 'REGENERATE_SESSIONS_ERROR',
        },
      },
      { status: 500 }
    );
  }
}

